<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trait Explorer Adventure 3D</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #gameContainer {
            position: absolute;
            width: 100%;
            height: 100%;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
        }
        
        #timer, #inventory {
            margin: 5px 0;
            font-weight: bold;
        }
        
        #prompt {
            margin: 10px 0;
        }
        
        #choices {
            margin-top: 10px;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        
        button:hover {
            background: #45a049;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
        }
        
        #results {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 200;
            display: none;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .avatars {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        
        .avatar {
            width: 80px;
            height: 100px;
            background: #333;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        
        .avatar:hover {
            background: #555;
        }
        
        .avatar-image {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 5px;
        }
        
        .avatar-name {
            color: white;
            font-size: 14px;
            font-weight: bold;
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 15px 0;
            text-align: left;
        }
        
        .stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 5px;
        }
        
        .item-label {
            position: absolute;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 10px;
            pointer-events: none;
            white-space: nowrap;
            transform: translate(-50%, -100%);
        }
        
        .collection-message {
            position: absolute;
            color: #4CAF50;
            font-weight: bold;
            pointer-events: none;
            animation: fadeUp 1s forwards;
        }
        
        @keyframes fadeUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-30px); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="loading">Loading 3D Game...</div>
    <div id="gameContainer"></div>
    
    <div id="ui">
        <div id="timer">Time: <span id="time">15</span>s</div>
        <div id="inventory">Items: <span id="inv">0/∞</span></div>
        <div id="prompt"></div>
        <div id="choices"></div>
    </div>
    
    <div id="instructions">
        Use Arrow Keys to move<br>
        Collect items by touching them
    </div>
    
    <div id="results">
        <h2>Game Results</h2>
        <div id="results-content"></div>
        <button onclick="location.reload()">Play Again</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let player, objects = [];
        let inventory = [];
        let timeLeft = 15;
        let timerInterval;
        let gamePhase = 0;
        let conscientiousnessScore = 0;
        let opennessScore = 0;
        let selectedAvatar = null;
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let playerSpeed = 0.1;
        let clock = new THREE.Clock();
        let safeDoor, mysteriousDoor;
        let doorsCreated = false;
        let portalParticles = [];
        let itemLabels = [];
        
        // Statistics tracking
        let startTime = Date.now();
        let totalMovementDistance = 0;
        let keyPressedCount = 0;
        let previousPlayerPosition = new THREE.Vector3(0, 0.5, 0);
        let collectedItemsCount = 0;
        
        const avatars = [
            { id: 1, name: "Alex", image: "1.jpg" },
            { id: 2, name: "Zoe", image: "2.jpg" },
            { id: 3, name: "Max", image: "3.jpg" },
            { id: 4, name: "Sam", image: "4.jpg" },
            { id: 5, name: "Riley", image: "5.jpg" }
        ];
        
        const items = [
            { name: "Wood", useful: true, color: 0x8B4513, description: "+1 to Crafting" },
            { name: "Food", useful: true, color: 0xD2691E, description: "+1 to Health" },
            { name: "Tool", useful: true, color: 0xC0C0C0, description: "+1 to Efficiency" },
            { name: "Trinket", useful: false, color: 0xFFD700, description: "+1 to Nostalgia" },
            { name: "Rope", useful: true, color: 0x8B4513, description: "+1 to Utility" },
            { name: "Metal", useful: true, color: 0xC0C0C0, description: "+1 to Durability" },
            { name: "Glass", useful: false, color: 0x888888, description: "+1 to Hazard" },
            { name: "Tarp", useful: true, color: 0x006400, description: "+1 to Shelter" },
            { name: "Stick", useful: true, color: 0x8B4513, description: "+1 to Exploration" },
            { name: "Crystal", useful: false, color: 0x4169E1, description: "+1 to 'Mystical Energy'" }
        ];

        window.addEventListener('load', init);

        function init() {
            document.getElementById('loading').style.display = 'none';
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('gameContainer').appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7);
            scene.add(directionalLight);
            
            // Ground (big square)
            const groundGeometry = new THREE.PlaneGeometry(50, 50);
            const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x2E8B57 });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);
            
            showAvatarSelection();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            animate();
        }
        
        function showAvatarSelection() {
            gamePhase = 0;
            clearScene();
            
            // Create avatar selection UI
            const container = document.createElement('div');
            container.style.position = 'absolute';
            container.style.top = '50%';
            container.style.left = '50%';
            container.style.transform = 'translate(-50%, -50%)';
            container.style.color = 'white';
            container.style.textAlign = 'center';
            container.style.zIndex = '50';
            container.id = 'avatar-selection';
            container.innerHTML = '<h2>Choose Your Avatar</h2>';
            
            const avatarsDiv = document.createElement('div');
            avatarsDiv.className = 'avatars';
            
            avatars.forEach(avatar => {
                const avatarDiv = document.createElement('div');
                avatarDiv.className = 'avatar';
                
                // Create image element
                const img = document.createElement('img');
                img.src = avatar.image;
                img.className = 'avatar-image';
                img.alt = avatar.name;
                img.onerror = function() {
                    // Fallback if image doesn't load
                    this.style.display = 'none';
                    const fallback = document.createElement('div');
                    fallback.style.width = '60px';
                    fallback.style.height = '60px';
                    fallback.style.backgroundColor = '#666';
                    fallback.style.borderRadius = '50%';
                    fallback.style.display = 'flex';
                    fallback.style.alignItems = 'center';
                    fallback.style.justifyContent = 'center';
                    fallback.style.fontSize = '24px';
                    fallback.textContent = '?';
                    avatarDiv.insertBefore(fallback, avatarDiv.firstChild);
                };
                
                const nameDiv = document.createElement('div');
                nameDiv.className = 'avatar-name';
                nameDiv.textContent = avatar.name;
                
                avatarDiv.appendChild(img);
                avatarDiv.appendChild(nameDiv);
                
                avatarDiv.onclick = () => {
                    selectAvatar(avatar);
                    if (document.getElementById('avatar-selection')) {
                        document.body.removeChild(container);
                    }
                };
                avatarsDiv.appendChild(avatarDiv);
            });
            
            container.appendChild(avatarsDiv);
            document.body.appendChild(container);
            
            showPrompt("Select an avatar to begin your adventure!");
        }
        
        function selectAvatar(avatar) {
            selectedAvatar = avatar;
            if (document.getElementById('avatar-selection')) {
                document.getElementById('avatar-selection').remove();
            }
            startConscientiousnessPhase();
        }
        
        function startConscientiousnessPhase() {
            gamePhase = 1;
            clearScene();
            doorsCreated = false;
            
            // Reset statistics
            totalMovementDistance = 0;
            keyPressedCount = 0;
            collectedItemsCount = 0;
            previousPlayerPosition = new THREE.Vector3(0, 0.5, 0);
            startTime = Date.now();
            
            // Create player
            const playerGeometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16);
            const playerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(0, 0.5, 0);
            scene.add(player);
            
            // Position camera (third-person view like Minecraft)
            updateCamera();
            
            // Create campsite environment
            createCampsiteEnvironment();
            
            startTimer();
            showPrompt("Storm incoming! Collect essential items in 15 seconds.");
        }
        
        function createCampsiteEnvironment() {
            // Create regular items
            items.forEach((item, i) => {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshBasicMaterial({ color: item.color });
                const cube = new THREE.Mesh(geometry, material);
                
                // Position items in a wider grid
                cube.position.set(
                    (i % 5) * 4 - 8,
                    0.5,
                    Math.floor(i / 5) * 4 - 8
                );
                
                cube.userData = { name: item.name, useful: item.useful, type: 'item', description: item.description };
                scene.add(cube);
                objects.push(cube);
                
                // Create label for the item
                createItemLabel(cube, item.name, item.description);
            });
            
            // Add secret prize at the edge of the map
            const secretGeometry = new THREE.OctahedronGeometry(0.8);
            const secretMaterial = new THREE.MeshBasicMaterial({ color: 0xFF00FF });
            const secretPrize = new THREE.Mesh(secretGeometry, secretMaterial);
            secretPrize.position.set(24, 0.8, 24); // At the edge of the 50x50 map
            secretPrize.userData = { name: "Secret Prize", useful: true, type: 'item', secret: true, description: "Special Bonus Item!" };
            scene.add(secretPrize);
            objects.push(secretPrize);
            
            // Create label for secret prize
            createItemLabel(secretPrize, "Secret Prize", "Special Bonus Item!");
            
            // Add some trees for environment
            for (let i = 0; i < 15; i++) {
                const treeTrunk = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 3, 8),
                    new THREE.MeshBasicMaterial({ color: 0x8B4513 })
                );
                treeTrunk.position.set(
                    (Math.random() - 0.5) * 40,
                    1.5,
                    (Math.random() - 0.5) * 40
                );
                scene.add(treeTrunk);
                
                const treeTop = new THREE.Mesh(
                    new THREE.ConeGeometry(1.5, 4, 8),
                    new THREE.MeshBasicMaterial({ color: 0x228B22 })
                );
                treeTop.position.set(
                    treeTrunk.position.x,
                    4,
                    treeTrunk.position.z
                );
                scene.add(treeTop);
            }
        }
        
        function createItemLabel(object, name, description) {
            // Create a div element for the label
            const label = document.createElement('div');
            label.className = 'item-label';
            label.innerHTML = `<strong>${name}</strong><br>${description}`;
            label.style.position = 'absolute';
            document.getElementById('gameContainer').appendChild(label);
            
            // Store reference to update position
            itemLabels.push({
                element: label,
                object: object
            });
        }
        
        function updateItemLabels() {
            itemLabels.forEach(labelInfo => {
                const label = labelInfo.element;
                const object = labelInfo.object;
                
                // Get 3D position and convert to screen coordinates
                const vector = object.position.clone();
                vector.project(camera);
                
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
                
                label.style.left = x + 'px';
                label.style.top = y + 'px';
            });
        }
        
        function startTimer() {
            clearInterval(timerInterval);
            timeLeft = 15;
            document.getElementById('time').textContent = timeLeft;
            
            timerInterval = setInterval(() => {
                timeLeft--;
                document.getElementById('time').textContent = timeLeft;
                if (timeLeft <= 0) {
                    endConscientiousnessPhase();
                }
            }, 1000);
        }
        
        function showPrompt(text) {
            document.getElementById('prompt').textContent = text;
        }
        
        function clearPrompt() {
            document.getElementById('prompt').textContent = '';
            document.getElementById('choices').innerHTML = '';
        }
        
        function onKeyDown(event) {
            keyPressedCount++; // Track key presses
            
            switch(event.key) {
                case 'ArrowUp': moveForward = true; break;
                case 'ArrowDown': moveBackward = true; break;
                case 'ArrowLeft': moveLeft = true; break;
                case 'ArrowRight': moveRight = true; break;
            }
        }
        
        function onKeyUp(event) {
            switch(event.key) {
                case 'ArrowUp': moveForward = false; break;
                case 'ArrowDown': moveBackward = false; break;
                case 'ArrowLeft': moveLeft = false; break;
                case 'ArrowRight': moveRight = false; break;
            }
        }
        
        function updatePlayer() {
            if (!player) return;
            
            const delta = clock.getDelta();
            
            // Calculate movement distance for statistics
            const oldPosition = player.position.clone();
            
            // Move player
            if (moveForward) {
                player.position.z -= playerSpeed;
            }
            if (moveBackward) {
                player.position.z += playerSpeed;
            }
            if (moveLeft) {
                player.position.x -= playerSpeed;
            }
            if (moveRight) {
                player.position.x += playerSpeed;
            }
            
            // Calculate distance moved
            const distanceMoved = oldPosition.distanceTo(player.position);
            totalMovementDistance += distanceMoved;
            
            // Keep player within bounds
            player.position.x = Math.max(-24, Math.min(24, player.position.x));
            player.position.z = Math.max(-24, Math.min(24, player.position.z));
            
            // Update camera to follow player (third-person view)
            updateCamera();
            
            // Check for collisions
            if (gamePhase === 1) {
                checkItemCollisions();
            } else if (gamePhase === 2) {
                checkDoorCollisions();
            }
        }
        
        function updateCamera() {
            if (!player) return;
            
            // Third-person camera position (behind and above player)
            const offsetX = 0;
            const offsetY = 3;
            const offsetZ = 5;
            
            camera.position.set(
                player.position.x + offsetX,
                player.position.y + offsetY,
                player.position.z + offsetZ
            );
            
            // Look at player
            camera.lookAt(player.position.x, player.position.y + 0.5, player.position.z);
        }
        
        function checkItemCollisions() {
            if (!player) return;
            
            for (let i = 0; i < objects.length; i++) {
                const obj = objects[i];
                if (obj.userData.type !== 'item') continue;
                
                const distance = player.position.distanceTo(obj.position);
                
                // If player is close to object
                if (distance < 1.5) {
                    const item = obj.userData;
                    collectItem(item, obj);
                    
                    // Remove object from scene and array
                    scene.remove(obj);
                    objects.splice(i, 1);
                    i--; // Adjust index after removal
                    
                    // Remove label
                    const labelIndex = itemLabels.findIndex(label => label.object === obj);
                    if (labelIndex !== -1) {
                        itemLabels[labelIndex].element.remove();
                        itemLabels.splice(labelIndex, 1);
                    }
                }
            }
        }
        
        function collectItem(item, mesh) {
            // Automatically add item to inventory
            inventory.push(item.name);
            document.getElementById('inv').textContent = `${inventory.length}/∞`;
            collectedItemsCount++;
            
            // Add to conscientiousness score if useful
            if (item.useful) {
                conscientiousnessScore += 1;
            }
            
            // Show collection message
            showCollectionMessage(`+${item.name}`, mesh.position);
            
            // Special handling for secret prize
            if (item.secret) {
                conscientiousnessScore += 2; // Bonus points
                showPrompt("Congratulations! You found the Secret Prize! +2 bonus points!");
            }
        }
        
        function showCollectionMessage(text, position) {
            const message = document.createElement('div');
            message.className = 'collection-message';
            message.textContent = text;
            
            // Convert 3D position to screen coordinates
            const vector = position.clone();
            vector.project(camera);
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
            
            message.style.left = x + 'px';
            message.style.top = y + 'px';
            message.style.position = 'absolute';
            message.style.color = '#4CAF50';
            message.style.fontWeight = 'bold';
            message.style.pointerEvents = 'none';
            
            document.getElementById('gameContainer').appendChild(message);
            
            // Remove message after animation
            setTimeout(() => {
                if (message.parentNode) {
                    message.parentNode.removeChild(message);
                }
            }, 1000);
        }
        
        function endConscientiousnessPhase() {
            clearInterval(timerInterval);
            showPrompt("Time's up! Find the doors to continue...");
            setTimeout(() => {
                createDoors();
            }, 2000);
        }
        
        function createDoors() {
            gamePhase = 2;
            if (doorsCreated) return;
            doorsCreated = true;
            
            // Remove remaining items and their labels
            for (let i = objects.length - 1; i >= 0; i--) {
                const obj = objects[i];
                if (obj.userData.type === 'item' && !obj.userData.secret) {
                    scene.remove(obj);
                    objects.splice(i, 1);
                }
            }
            
            // Remove labels for remaining items
            for (let i = itemLabels.length - 1; i >= 0; i--) {
                const labelInfo = itemLabels[i];
                if (labelInfo.object.userData.type === 'item' && !labelInfo.object.userData.secret) {
                    labelInfo.element.remove();
                    itemLabels.splice(i, 1);
                }
            }
            
            // Create safe door (normal door) - more detailed
            createSafeDoor();
            
            // Create mysterious door (magical portal) - more detailed
            createMysteriousPortal();
            
            showPrompt("Find and enter a door: Normal Door or Magical Portal");
        }
        
        function createSafeDoor() {
            // Door frame
            const frameGeometry = new THREE.BoxGeometry(3, 4, 0.3);
            const frameMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
            const doorFrame = new THREE.Mesh(frameGeometry, frameMaterial);
            doorFrame.position.set(-10, 2, -15);
            scene.add(doorFrame);
            
            // Door panel
            const panelGeometry = new THREE.BoxGeometry(2.5, 3.5, 0.2);
            const panelMaterial = new THREE.MeshBasicMaterial({ color: 0xA0522D });
            const doorPanel = new THREE.Mesh(panelGeometry, panelMaterial);
            doorPanel.position.set(-10, 2, -14.8);
            scene.add(doorPanel);
            
            // Door handle
            const handleGeometry = new THREE.TorusGeometry(0.1, 0.05, 16, 32);
            const handleMaterial = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
            const doorHandle = new THREE.Mesh(handleGeometry, handleMaterial);
            doorHandle.position.set(-9, 2, -14.7);
            doorHandle.rotation.y = Math.PI / 2;
            scene.add(doorHandle);
            
            // Door label
            const labelGeometry = new THREE.BoxGeometry(1.5, 0.5, 0.1);
            const labelMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            const doorLabel = new THREE.Mesh(labelGeometry, labelMaterial);
            doorLabel.position.set(-10, 3.5, -14.7);
            scene.add(doorLabel);
            
            // Group all door elements
            safeDoor = new THREE.Group();
            safeDoor.add(doorFrame);
            safeDoor.add(doorPanel);
            safeDoor.add(doorHandle);
            safeDoor.add(doorLabel);
            safeDoor.position.set(-10, 0, -15);
            safeDoor.userData = { type: 'door', doorType: 'safe' };
            scene.add(safeDoor);
            objects.push(safeDoor);
        }
        
        function createMysteriousPortal() {
            // Portal ring
            const ringGeometry = new THREE.TorusGeometry(2, 0.3, 16, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x4169E1,
                emissive: 0x191970
            });
            const portalRing = new THREE.Mesh(ringGeometry, ringMaterial);
            portalRing.position.set(10, 2, -15);
            portalRing.rotation.x = Math.PI / 2;
            scene.add(portalRing);
            
            // Portal core
            const coreGeometry = new THREE.SphereGeometry(1.5, 32, 32);
            const coreMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x8A2BE2,
                transparent: true,
                opacity: 0.7
            });
            const portalCore = new THREE.Mesh(coreGeometry, coreMaterial);
            portalCore.position.set(10, 2, -15);
            scene.add(portalCore);
            
            // Portal energy effect
            const energyGeometry = new THREE.RingGeometry(0.5, 1.8, 32);
            const energyMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x00FFFF,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5
            });
            const portalEnergy = new THREE.Mesh(energyGeometry, energyMaterial);
            portalEnergy.position.set(10, 2, -15);
            portalEnergy.rotation.x = Math.PI / 2;
            scene.add(portalEnergy);
            
            // Portal particles
            createPortalParticles();
            
            // Portal label
            const labelGeometry = new THREE.BoxGeometry(2, 0.5, 0.1);
            const labelMaterial = new THREE.MeshBasicMaterial({ color: 0xFFFFFF });
            const portalLabel = new THREE.Mesh(labelGeometry, labelMaterial);
            portalLabel.position.set(10, 4, -15);
            scene.add(portalLabel);
            
            // Group all portal elements
            mysteriousDoor = new THREE.Group();
            mysteriousDoor.add(portalRing);
            mysteriousDoor.add(portalCore);
            mysteriousDoor.add(portalEnergy);
            mysteriousDoor.add(portalLabel);
            mysteriousDoor.position.set(10, 0, -15);
            mysteriousDoor.userData = { type: 'door', doorType: 'mysterious' };
            scene.add(mysteriousDoor);
            objects.push(mysteriousDoor);
        }
        
        function createPortalParticles() {
            // Create floating particles around the portal
            for (let i = 0; i < 20; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00FFFF,
                    transparent: true,
                    opacity: 0.8
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Random position around portal
                const angle = Math.random() * Math.PI * 2;
                const radius = 1 + Math.random() * 2;
                particle.position.set(
                    10 + Math.cos(angle) * radius,
                    2 + (Math.random() - 0.5) * 2,
                    -15 + Math.sin(angle) * radius
                );
                
                particle.userData = { 
                    originalY: particle.position.y,
                    speed: 0.02 + Math.random() * 0.03,
                    offset: Math.random() * Math.PI * 2
                };
                
                scene.add(particle);
                portalParticles.push(particle);
            }
        }
        
        function updatePortalEffects() {
            if (mysteriousDoor && gamePhase === 2) {
                // Rotate portal elements
                mysteriousDoor.rotation.y += 0.005;
                
                // Animate portal particles
                const time = Date.now() * 0.001;
                portalParticles.forEach(particle => {
                    particle.position.y = particle.userData.originalY + Math.sin(time * particle.userData.speed + particle.userData.offset) * 0.5;
                    particle.rotation.x += 0.02;
                    particle.rotation.y += 0.02;
                });
                
                // Pulsing effect for portal core
                const scale = 1 + Math.sin(time * 2) * 0.1;
                mysteriousDoor.children[1].scale.set(scale, scale, scale);
            }
        }
        
        function checkDoorCollisions() {
            if (!player || !safeDoor || !mysteriousDoor) return;
            
            // Check safe door collision
            const safeDistance = player.position.distanceTo(new THREE.Vector3(-10, 2, -15));
            if (safeDistance < 2.5) {
                choosePath('safe');
                return;
            }
            
            // Check mysterious door collision
            const mystDistance = player.position.distanceTo(new THREE.Vector3(10, 2, -15));
            if (mystDistance < 2.5) {
                choosePath('mysterious');
                return;
            }
        }
        
        function choosePath(path) {
            gamePhase = 3; // End phase
            
            if (path === 'safe') {
                opennessScore -= 1;
                showPrompt("You entered the normal door. Safe but predictable.");
            } else {
                opennessScore += 2;
                showPrompt("You entered the magical portal! Mysterious adventures await.");
            }
            
            // Stop player movement
            moveForward = false;
            moveBackward = false;
            moveLeft = false;
            moveRight = false;
            
            setTimeout(showResults, 2000);
        }
        
        function showResults() {
            const endTime = Date.now();
            const totalTimeSpent = Math.round((endTime - startTime) / 1000); // in seconds
            
            const conscientiousnessText = conscientiousnessScore >= 4 ? "High" : conscientiousnessScore >= 2 ? "Medium" : "Low";
            const opennessText = opennessScore >= 2 ? "High" : opennessScore >= 0 ? "Medium" : "Low";
            
            let psychologicalRole = "";
            switch(selectedAvatar.id) {
                case 1: psychologicalRole = "The Organizer - You naturally take charge in crisis situations."; break;
                case 2: psychologicalRole = "The Visionary - You approach challenges with creativity and imagination."; break;
                case 3: psychologicalRole = "The Executor - You act swiftly and decisively."; break;
                case 4: psychologicalRole = "The Strategist - You carefully analyze situations before making decisions."; break;
                case 5: psychologicalRole = "The Collaborator - You consider how your choices affect others."; break;
                default: psychologicalRole = "The Explorer - Your unique combination of traits makes you adaptable.";
            }
            
            const resultsContent = `
                <p><strong>Avatar:</strong> ${selectedAvatar.name}</p>
                <p><strong>Psychological Role:</strong> ${psychologicalRole}</p>
                
                <div class="stats-grid">
                    <div class="stat-item">
                        <strong>Conscientiousness:</strong><br>
                        ${conscientiousnessText} (${conscientiousnessScore}/5)
                    </div>
                    <div class="stat-item">
                        <strong>Openness:</strong><br>
                        ${opennessText} (${opennessScore}/3)
                    </div>
                    <div class="stat-item">
                        <strong>Items Collected:</strong><br>
                        ${collectedItemsCount}
                    </div>
                    <div class="stat-item">
                        <strong>Total Time:</strong><br>
                        ${totalTimeSpent} seconds
                    </div>
                    <div class="stat-item">
                        <strong>Movement Distance:</strong><br>
                        ${totalMovementDistance.toFixed(2)} units
                    </div>
                    <div class="stat-item">
                        <strong>Keys Pressed:</strong><br>
                        ${keyPressedCount}
                    </div>
                </div>
                
                <p><strong>Performance Analysis:</strong></p>
                <p style="font-size: 14px; text-align: left;">
                    You moved a total of ${totalMovementDistance.toFixed(2)} units across the map, 
                    pressing keys ${keyPressedCount} times during gameplay. 
                    You collected ${collectedItemsCount} items in ${totalTimeSpent} seconds.
                    ${keyPressedCount > 50 ? "You're very active in exploring the environment!" : 
                      keyPressedCount > 20 ? "You explored the environment with moderate activity." : 
                      "You moved efficiently with minimal key presses."}
                </p>
            `;
            
            document.getElementById('results-content').innerHTML = resultsContent;
            document.getElementById('results').style.display = 'block';
            document.getElementById('ui').style.display = 'none';
            document.getElementById('instructions').style.display = 'none';
        }
        
        function clearScene() {
            // Remove all objects except lights and camera
            for (let i = scene.children.length - 1; i >= 0; i--) {
                const obj = scene.children[i];
                if (obj !== camera) {
                    scene.remove(obj);
                }
            }
            
            // Remove all labels
            itemLabels.forEach(labelInfo => {
                labelInfo.element.remove();
            });
            itemLabels = [];
            
            objects = [];
            player = null;
            safeDoor = null;
            mysteriousDoor = null;
            doorsCreated = false;
            portalParticles = [];
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update player movement
            updatePlayer();
            
            // Update portal effects
            updatePortalEffects();
            
            // Update item labels
            updateItemLabels();
            
            // Rotate secret prize for visual effect
            objects.forEach(obj => {
                if (obj.userData && obj.userData.secret) {
                    obj.rotation.x += 0.01;
                    obj.rotation.y += 0.01;
                }
            });
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>