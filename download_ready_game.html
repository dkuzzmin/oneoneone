<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D –õ–∞–±–∏—Ä–∏–Ω—Ç</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameCanvas {
            display: block;
            margin: 0 auto;
            border: 2px solid #fff;
            border-radius: 10px;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            z-index: 100;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-align: center;
            font-size: 14px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        #winMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,255,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            font-size: 24px;
            text-align: center;
            display: none;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div id="ui">
        <div>–°–æ–±—Ä–∞–Ω–æ –∫—Ä–∏—Å—Ç–∞–ª–ª–æ–≤: <span id="score">0</span>/5</div>
        <div>–í—Ä–µ–º—è: <span id="time">0</span>—Å</div>
    </div>
    
    <div id="controls">
        –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: WASD –∏–ª–∏ —Å—Ç—Ä–µ–ª–∫–∏ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è | –ú—ã—à—å –¥–ª—è –ø–æ–≤–æ—Ä–æ—Ç–∞ –∫–∞–º–µ—Ä—ã
    </div>
    
    <div id="winMessage">
        <h2>üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! üéâ</h2>
        <p>–í—ã —Å–æ–±—Ä–∞–ª–∏ –≤—Å–µ –∫—Ä–∏—Å—Ç–∞–ª–ª—ã!</p>
        <p>–í—Ä–µ–º—è: <span id="finalTime"></span>—Å</p>
        <button onclick="restartGame()">–ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        let scene, camera, renderer, player, crystals = [], walls = [];
        let moveState = { forward: false, backward: false, left: false, right: false };
        let score = 0;
        let startTime = Date.now();
        let gameWon = false;
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å—Ü–µ–Ω—ã
        function initGame() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // –°–æ–∑–¥–∞–Ω–∏–µ –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
            createMaze();
            createPlayer();
            createCrystals();
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
            setupControls();
            
            // –ó–∞–ø—É—Å–∫ –∏–≥—Ä–æ–≤–æ–≥–æ —Ü–∏–∫–ª–∞
            animate();
        }
        
        function createMaze() {
            // –ü–æ–ª
            const floorGeometry = new THREE.PlaneGeometry(50, 50);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x90EE90 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // –°—Ç–µ–Ω—ã –ª–∞–±–∏—Ä–∏–Ω—Ç–∞
            const wallPositions = [
                // –í–Ω–µ—à–Ω–∏–µ —Å—Ç–µ–Ω—ã
                [-25, 0], [25, 0], [0, -25], [0, 25],
                // –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Å—Ç–µ–Ω—ã
                [-15, -10], [-15, 10], [15, -10], [15, 10],
                [-5, -15], [-5, 15], [5, -15], [5, 15],
                [-10, 0], [10, 0], [0, -10], [0, 10]
            ];
            
            wallPositions.forEach(pos => {
                createWall(pos[0], pos[1]);
            });
        }
        
        function createWall(x, z) {
            const wallGeometry = new THREE.BoxGeometry(2, 4, 2);
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.set(x, 2, z);
            wall.castShadow = true;
            wall.receiveShadow = true;
            walls.push(wall);
            scene.add(wall);
        }
        
        function createPlayer() {
            const playerGeometry = new THREE.BoxGeometry(1, 1, 1);
            const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.position.set(-20, 0.5, -20);
            player.castShadow = true;
            scene.add(player);
            
            // –ö–∞–º–µ—Ä–∞ —Å–ª–µ–¥—É–µ—Ç –∑–∞ –∏–≥—Ä–æ–∫–æ–º
            camera.position.set(-20, 5, -15);
            camera.lookAt(player.position);
        }
        
        function createCrystals() {
            const crystalPositions = [
                [18, 18], [-18, 18], [18, -18], [-18, -18], [0, 0]
            ];
            
            crystalPositions.forEach(pos => {
                const crystalGeometry = new THREE.OctahedronGeometry(0.8);
                const crystalMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0xFF69B4,
                    transparent: true,
                    opacity: 0.8
                });
                const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
                crystal.position.set(pos[0], 1.5, pos[1]);
                crystal.castShadow = true;
                crystals.push(crystal);
                scene.add(crystal);
            });
        }
        
        function setupControls() {
            document.addEventListener('keydown', (event) => {
                switch(event.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        moveState.forward = true;
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        moveState.backward = true;
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        moveState.left = true;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        moveState.right = true;
                        break;
                }
            });
            
            document.addEventListener('keyup', (event) => {
                switch(event.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        moveState.forward = false;
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        moveState.backward = false;
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        moveState.left = false;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        moveState.right = false;
                        break;
                }
            });
            
            // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º—ã—à—å—é –¥–ª—è –ø–æ–≤–æ—Ä–æ—Ç–∞ –∫–∞–º–µ—Ä—ã
            let mouseX = 0, mouseY = 0;
            let isMouseDown = false;
            
            document.addEventListener('mousedown', () => isMouseDown = true);
            document.addEventListener('mouseup', () => isMouseDown = false);
            document.addEventListener('mousemove', (event) => {
                if (isMouseDown) {
                    mouseX = (event.clientX / window.innerWidth) * 2 - 1;
                    mouseY = -(event.clientY / window.innerHeight) * 2 + 1;
                }
            });
        }
        
        function updatePlayer() {
            if (gameWon) return;
            
            const speed = 0.15;
            const newPosition = player.position.clone();
            
            if (moveState.forward) newPosition.z -= speed;
            if (moveState.backward) newPosition.z += speed;
            if (moveState.left) newPosition.x -= speed;
            if (moveState.right) newPosition.x += speed;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å–æ —Å—Ç–µ–Ω–∞–º–∏
            let collision = false;
            walls.forEach(wall => {
                const distance = newPosition.distanceTo(wall.position);
                if (distance < 2) {
                    collision = true;
                }
            });
            
            // –ì—Ä–∞–Ω–∏—Ü—ã –∫–∞—Ä—Ç—ã
            if (newPosition.x > 24 || newPosition.x < -24 || 
                newPosition.z > 24 || newPosition.z < -24) {
                collision = true;
            }
            
            if (!collision) {
                player.position.copy(newPosition);
                
                // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∫–∞–º–µ—Ä—ã
                camera.position.x = player.position.x;
                camera.position.z = player.position.z + 5;
                camera.lookAt(player.position);
            }
            
            // –í—Ä–∞—â–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
            player.rotation.y += 0.02;
        }
        
        function checkCrystalCollection() {
            crystals.forEach((crystal, index) => {
                if (crystal.visible) {
                    const distance = player.position.distanceTo(crystal.position);
                    if (distance < 2) {
                        crystal.visible = false;
                        score++;
                        document.getElementById('score').textContent = score;
                        
                        if (score >= 5) {
                            winGame();
                        }
                    }
                }
            });
        }
        
        function updateCrystals() {
            crystals.forEach(crystal => {
                if (crystal.visible) {
                    crystal.rotation.y += 0.05;
                    crystal.position.y = 1.5 + Math.sin(Date.now() * 0.002) * 0.3;
                }
            });
        }
        
        function updateUI() {
            if (!gameWon) {
                const currentTime = Math.floor((Date.now() - startTime) / 1000);
                document.getElementById('time').textContent = currentTime;
            }
        }
        
        function winGame() {
            gameWon = true;
            const finalTime = Math.floor((Date.now() - startTime) / 1000);
            document.getElementById('finalTime').textContent = finalTime;
            document.getElementById('winMessage').style.display = 'block';
        }
        
        function restartGame() {
            // –°–±—Ä–æ—Å –∏–≥—Ä—ã
            score = 0;
            gameWon = false;
            startTime = Date.now();
            
            document.getElementById('score').textContent = '0';
            document.getElementById('time').textContent = '0';
            document.getElementById('winMessage').style.display = 'none';
            
            // –í–æ–∑–≤—Ä–∞—Ç –∏–≥—Ä–æ–∫–∞ –≤ –Ω–∞—á–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
            player.position.set(-20, 0.5, -20);
            camera.position.set(-20, 5, -15);
            
            // –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –∫—Ä–∏—Å—Ç–∞–ª–ª—ã —Å–Ω–æ–≤–∞
            crystals.forEach(crystal => {
                crystal.visible = true;
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            updatePlayer();
            checkCrystalCollection();
            updateCrystals();
            updateUI();
            
            renderer.render(scene, camera);
        }
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
        initGame();
    </script>
</body>
</html>